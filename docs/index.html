<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>journeyman-0.1.0.0</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">journeyman-0.1.0.0</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="description"><h1>journeyman-0.1.0.0</h1><div class="doc"><p>Journeyman is my undergraduate COMP4560 project, with the aim to
create an easy-to-use eDSL that can be used to create and analyse arbitrary
tournament structures; such as &quot;common&quot; ones like Single or Double
Elimination, or compositions like N groups of Single Elimination.</p><ul><li>Your entrypoint to the eDSL should be the <a href="Tourney-Algebra.html">Tourney.Algebra</a> module.</li><li>Your entrypoint to exploring what's possible with Journeyman should be
the journeyman-ui executable that comes bundled with this package. It
uses an extensible tournament UI defined in <a href="Tourney-UI-Main.html">Tourney.UI.Main</a>, but all
you as a user needs to do is extend the list of known tournaments you
pass to <code>createTourneyUI</code> with a tournament you create.
For an example of how to do this, see the executable in <code> app/Main.hs </code>.</li><li>To create a special-purpose tournament VM, for instance, to simulate
a tournament structure under different conditions, see the <a href="Tourney-VM.html">Tourney.VM</a>
module.</li><li>Functions dealing merely with sorting networks or point-award based
sorting networks such as those supported by Journeyman can be found in
<a href="Tourney-SortingNetwork.html">Tourney.SortingNetwork</a></li></ul><p>Some example tournament structures are provided under the <code> Tourney.Format.* </code>
module. Navigating to these and familiarising yourself with the source code via
the <em>Source</em> links may be quite helpful in gaining an intuition for how
Journeyman works and what its capabilities are.</p><h1>Analogies between sorting networks and tournaments</h1><p>A key observation of made at the outset of this project is that there is an
analogy between sorting networks and many tournament structures. Here, a sorting
network refers to a fixed schedule or &quot;network&quot; of comparisons between a fixed
set of objects. Each comparison has a fixed coordinate or <em>wire</em> in the network,
and results in either the objects staying in the same position as they were (if
they were already in order with respect to eachother), or they exchange places
if not.</p><p>I call a sorting network &quot;partial&quot; if it does not determine a complete ordering
among players; for instance if out of 16 elements it determines the greatest 8
in order, but leaves the remaining 8 in two buckets of 4 items where only the
order of the buckets is known.</p><p>A Single Elimination tournament has a partial sorting network construction. This
is because at each round we can draw matches between the winners of the previous
round only; that is, those players that now occupy the &quot;high&quot; position of the
sorting network, after a single step of the network. At the same time, the
losers of each round are simply not given any further comparisons (i.e.,
matches) from the point that they were eliminated, and so remain ranked at
whatever point they were eliminated.</p><p>Similarly, we can also construct a Double-Elimination tournament by sorting
network, by creating matches between those players that lost in first round of
the &quot;upper&quot; bracket, and then alternating rounds that either accept new losers
from the previous upper bracket round into new matches in the lower bracket, or
that play off players who are in the lower bracket. Not all tournaments are
sorting networks however. For instance, a round robin tournament has no
sorting network equivalent, even though it has a fully-determined
schedule for <span class="mathjax">\(n\)</span> players. To get around this, we define a special primitive that
allows the method by which players exchange positions to be redefined; for
instance, in a round robin, the method is that players shall accumulate points
by winning matches, and then be ordered from most points to least.</p></div></div><div id="module-list"><p class="caption">Modules</p><div id="module-list"><p class="caption">journeyman-0.1.0.0</p><ul><li><span class="module details-toggle-control details-toggle" data-details-id="n.1">Tourney</span><details id="n.1" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><span class="details-toggle-control details-toggle" data-details-id="n.1.1">&nbsp;</span><a href="Tourney-Algebra.html">Tourney.Algebra</a></span><details id="n.1.1" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Algebra-Builder.html">Tourney.Algebra.Builder</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Algebra-Unified.html">Tourney.Algebra.Unified</a></span></li></ul></details></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Common.html">Tourney.Common</a></span></li><li><span class="module details-toggle-control details-toggle" data-details-id="n.1.3">Format</span><details id="n.1.3" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Format-DoubleElimination.html">Tourney.Format.DoubleElimination</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Format-ICantBelieveItCanSort.html">Tourney.Format.ICantBelieveItCanSort</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Format-InsertionSort.html">Tourney.Format.InsertionSort</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Format-OptimalSortingNetwork.html">Tourney.Format.OptimalSortingNetwork</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Format-RoundRobin.html">Tourney.Format.RoundRobin</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Format-SingleElimination.html">Tourney.Format.SingleElimination</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Format-Swiss.html">Tourney.Format.Swiss</a></span></li></ul></details></li><li><span class="module"><span class="details-toggle-control details-toggle" data-details-id="n.1.4">&nbsp;</span><a href="Tourney-Match.html">Tourney.Match</a></span><details id="n.1.4" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Match-Matrix.html">Tourney.Match.Matrix</a></span></li></ul></details></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-SortingNetwork.html">Tourney.SortingNetwork</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-Stream.html">Tourney.Stream</a></span></li><li><span class="module details-toggle-control details-toggle" data-details-id="n.1.7">UI</span><details id="n.1.7" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-UI-Main.html">Tourney.UI.Main</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-UI-Selection.html">Tourney.UI.Selection</a></span></li></ul></details></li><li><span class="module"><span class="details-toggle-control details-toggle" data-details-id="n.1.8">&nbsp;</span><a href="Tourney-VM.html">Tourney.VM</a></span><details id="n.1.8" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-VM-Code.html">Tourney.VM.Code</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-VM-Compile.html">Tourney.VM.Compile</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Tourney-VM-Interpret.html">Tourney.VM.Interpret</a></span></li></ul></details></li></ul></details></li></ul></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.27.0</p></div></body></html>